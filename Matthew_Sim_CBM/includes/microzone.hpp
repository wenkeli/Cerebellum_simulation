#ifndef MICROZONE_HPP
#define MICROZONE_HPP

#include <CXXToolsInclude/stdDefinitions/pstdint.h>
#include <CBMCoreInclude/interface/cbmsimcore.h>
#include <CBMStateInclude/interfaces/cbmstate.h>
#include <CBMToolsInclude/poissonregencells.h>
#include <fstream>
#include <queue>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>


// This class is a wrapper for a Microzone
class Microzone {
private:
    friend class boost::serialization::access;
    template <class Archive>
    void serialize(Archive &ar, const unsigned int version) {
        (void)version;
        ar & name;
        ar & mzNum;
        ar & forceScale;
        ar & forceScale;
        ar & forcePow;
        ar & forceDecay;
    }

public:
    // Default constructor
    Microzone();

    // Standard constructor
    Microzone(std::string name, int mzNum,
              float forceScale, float forcePow, float forceDecay,
              int numNC=0, CBMSimCore *simCore=NULL);
    
public:
    // Initialize this MZ by providing it with the core
    void initialize(CBMSimCore *core, int numNC);

    // Check if this MZ has been initialized
    bool initialized();

    // Delivers and error signal to this MZ
    void deliverError(); 

    // Delivers error only if the MZ has not been reaching max
    // force output. This prevents the MZ from being over-saturated
    // by error signals.
    void smartDeliverError();

    // Pulls the latest firings and updates the force & average.
    // This should be called only once per cycle.
    void update();

    // Returns the force generated by the MZ
    float getForce() { return force; }

    // Returns the moving average of NC firings
    float getMovingAverage() { return movingAvg; }

    // Get the raw NC firings
    const ct_uint8_t* getApNC();

    // Get the MZ name
    std::string getName() { return name; }

    // Set the MZ name
    void setName(std::string newName) { name = newName; }

protected:
    std::string name;
    int mzNum, numNC;
    float force, forceScale, forcePow, forceDecay;
    CBMSimCore *simCore;

    // Variables used to keep a running avg of MZ firings
    static const uint windowLength = 100;
    std::queue<float> actQueue;
    float actSum, movingAvg;

    static const float errSaturatedThreshold = .8;
};

#endif
