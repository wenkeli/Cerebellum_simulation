#ifndef ROBOCUP_HPP
#define ROBOCUP_HPP

#include "environment.hpp"
#include "statevariable.hpp"
#include "microzone.hpp"
#include "agentInterface.hpp"
#include "optimizationbehaviors.h"
#include "bodymodel.h"
#include "worldmodel.h"
#include "core_utwalk/motion/UTWalkEngine.h"

#include <boost/filesystem.hpp>

class Robocup : public Environment {
public:
    Robocup() : Environment(NULL) {}
    Robocup(CRandomSFMT0 *randGen, int argc, char **argv);
    ~Robocup();
    int numRequiredMZ() { return 1; }
    void setupMossyFibers(CBMState *simState);
    float* getState();
    void step(CBMSimCore *simCore);
    bool terminated();
    static boost::program_options::options_description getOptions();
    
    float getTimeToImpact() { return behavior->getTimeToShot(); }
    float getTimeSinceTrialStart() { return behavior->getTimeSinceTrialStart(); }
    float getGyroX() { return bodyModel->getGyroRates().getX(); }
    float getGyroY() { return bodyModel->getGyroRates().getY(); }
    float getGyroZ() { return bodyModel->getGyroRates().getZ(); }
    float getAccelX() { return bodyModel->getAccelRates().getX(); }
    float getAccelY() { return bodyModel->getAccelRates().getY(); }
    float getAccelZ() { return bodyModel->getAccelRates().getZ(); }
    float getHipPitch() { return bodyModel->getJointAngle(HJ_LL3); }
    float getCOMX() { return walkEngine->getCOM().x; }
    float getCOMY() { return walkEngine->getCOM().y; }
    float getCOMZ() { return walkEngine->getCOM().z; }    

protected:
    void deliverErrors();
    void calcForce();

protected:
    std::ofstream logfile;
    boost::filesystem::path saveStateDir; // Directory to save sim state files

    AgentInterface robosim;
    OptimizationBehaviorBalance *behavior;
    BodyModel *bodyModel;
    WorldModel *worldModel;
    UTWalkEngine *walkEngine;

    Microzone mz_hipPitchForwards;//, mz_hipPitchBack; 
    StateVariable<Robocup> sv_highFreq, sv_impactTimer; //, sv_hipPitch;

    // Min & Max observed gyro (x,y,z) values
    // Current angular velocities along the three axes of freedom of the corresponding body in degrees per second
    static const float minGX = -134; //-425.9;
    static const float minGY = -256.67;
    static const float minGZ = -570.2;
    static const float maxGX = 134; //519.74;
    static const float maxGY = 253.81;
    static const float maxGZ = 557.51;

    // Min & Max observed accelerometer (x,y,z) values
    // Current acceleration along the three axes of freedom of the corresponding body in m/s^2
    static const float minAX = -9.831106;
    static const float minAY = -4.661584;
    static const float minAZ = -10.673100;
    static const float maxAX = 10.25562;
    static const float maxAY = 4.785766;
    static const float maxAZ = 5.432633;
    static const float maxImpactTimerVal = 1.5;
    static const float minImpactTimerVal = -1.5;
    static const float minHipPitch = 0;
    static const float maxHipPitch = 45;

    static const bool randomizeMFs = false;

    static const float forceScale = 6;  // Force gain for the output
    static const float forcePow = 4;     // Force power for the output
    static const float forceDecay = .99; // Rate a which force decays

    // Sums of forces generated by the MZs
    float hpFF, hpBF, avgHipPitchForce;

    // Number of cerebellar steps for each robosim step
    static const int cbm_steps_to_robosim_steps = 20; 

    // Maximum number of trials until termination
    int maxNumTrials;
};

#endif
